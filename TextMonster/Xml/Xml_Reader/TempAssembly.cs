using System;
using System.Collections;
using System.Reflection;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Permissions;
using System.Security.Policy;

namespace TextMonster.Xml.Xml_Reader
{
  internal class TempAssembly
  {
    internal const string GeneratedAssemblyNamespace = "Microsoft.Xml.Serialization.GeneratedAssembly";
    Assembly assembly;
    bool pregeneratedAssmbly = false;
    XmlSerializerImplementation contract = null;
    Hashtable writerMethods;
    Hashtable readerMethods;
    TempMethodDictionary methods;
    Hashtable assemblies = new Hashtable();
    static volatile FileIOPermission fileIOPermission;

    internal class TempMethod
    {
      internal MethodInfo writeMethod;
      internal MethodInfo readMethod;
      internal bool isSoap;
    }

    internal TempAssembly(XmlMapping[] xmlMappings, Type[] types, string defaultNamespace, string location, Evidence evidence)
    {
      bool containsSoapMapping = false;
      for (int i = 0; i < xmlMappings.Length; i++)
      {
        xmlMappings[i].CheckShallow();
        if (xmlMappings[i].IsSoap)
        {
          containsSoapMapping = true;
        }
      }

      // We will make best effort to use RefEmit for assembly generation
      bool fallbackToCSharpAssemblyGeneration = false;

      if (!containsSoapMapping && !TempAssembly.UseLegacySerializerGeneration)
      {
        try
        {
          assembly = GenerateRefEmitAssembly(xmlMappings, types, defaultNamespace, evidence);
        }
        // Only catch and handle known failures with RefEmit
        catch (CodeGeneratorConversionException)
        {
          fallbackToCSharpAssemblyGeneration = true;
        }
        // Add other known exceptions here...
        //
      }
      else
      {
        fallbackToCSharpAssemblyGeneration = true;
      }

      InitAssemblyMethods(xmlMappings);
    }

    internal TempAssembly(XmlMapping[] xmlMappings, Assembly assembly, XmlSerializerImplementation contract)
    {
      this.assembly = assembly;
      InitAssemblyMethods(xmlMappings);
      this.contract = contract;
      pregeneratedAssmbly = true;
    }

    internal static bool UseLegacySerializerGeneration
    {
      get
      {
        return true;
      }
    }

    internal XmlSerializerImplementation Contract
    {
      get
      {
        if (contract == null)
        {
          contract = (XmlSerializerImplementation)Activator.CreateInstance(GetTypeFromAssembly(this.assembly, "XmlSerializerContract"));
        }
        return contract;
      }
    }

    internal void InitAssemblyMethods(XmlMapping[] xmlMappings)
    {
      methods = new TempMethodDictionary();
      for (int i = 0; i < xmlMappings.Length; i++)
      {
        TempMethod method = new TempMethod();
        method.isSoap = xmlMappings[i].IsSoap;
        XmlTypeMapping xmlTypeMapping = xmlMappings[i] as XmlTypeMapping;
        if (xmlTypeMapping != null)
        {
        }
        methods.Add(xmlMappings[i].Key, method);
      }
    }

    /// <devdoc>
    ///    <para>
    ///    Attempts to load pre-generated serialization assembly.
    ///    First check for the [XmlSerializerAssembly] attribute
    ///    </para>
    /// </devdoc>
    // SxS: This method does not take any resource name and does not expose any resources to the caller.
    // It's OK to suppress the SxS warning.
    [ResourceConsumption(ResourceScope.Machine, ResourceScope.Machine)]
    [ResourceExposure(ResourceScope.None)]
    internal static Assembly LoadGeneratedAssembly(Type type, string defaultNamespace, out XmlSerializerImplementation contract)
    {
      Assembly serializer = null;
      contract = null;
      string serializerName = null;

      // Packaged apps do not support loading generated serializers.
      return null;
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2106:SecureAsserts", Justification = "It is safe because the serialization assembly is generated by the framework code, not by the user.")]
    internal static Assembly GenerateRefEmitAssembly(XmlMapping[] xmlMappings, Type[] types, string defaultNamespace, Evidence evidence)
    {
      return null;
    }

    // SxS: This method does not take any resource name and does not expose any resources to the caller.
    // It's OK to suppress the SxS warning.
    [ResourceConsumption(ResourceScope.Machine, ResourceScope.Machine)]
    [ResourceExposure(ResourceScope.None)]
    static MethodInfo GetMethodFromType(Type type, string methodName, Assembly assembly)
    {
      MethodInfo method = type.GetMethod(methodName);
      if (method != null)
        return method;

      MissingMethodException missingMethod = new MissingMethodException(type.FullName, methodName);
      if (assembly != null)
      {
        throw new InvalidOperationException(Res.GetString(Res.XmlSerializerExpired, assembly.FullName, assembly.CodeBase), missingMethod);
      }
      throw missingMethod;
    }

    internal static Type GetTypeFromAssembly(Assembly assembly, string typeName)
    {
      typeName = GeneratedAssemblyNamespace + "." + typeName;
      Type type = assembly.GetType(typeName);
      if (type == null) throw new InvalidOperationException(Res.GetString(Res.XmlMissingType, typeName, assembly.FullName));
      return type;
    }

    string ValidateEncodingStyle(string encodingStyle, string methodKey)
    {
      if (encodingStyle != null && encodingStyle.Length > 0)
      {
        if (methods[methodKey].isSoap)
        {
          if (encodingStyle != Soap.Encoding && encodingStyle != Soap12.Encoding)
          {
            throw new InvalidOperationException(Res.GetString(Res.XmlInvalidEncoding3, encodingStyle, Soap.Encoding, Soap12.Encoding));
          }
        }
        else
        {
          throw new InvalidOperationException(Res.GetString(Res.XmlInvalidEncodingNotEncoded1, encodingStyle));
        }
      }
      else
      {
        if (methods[methodKey].isSoap)
        {
          encodingStyle = Soap.Encoding;
        }
      }
      return encodingStyle;
    }

    internal void InvokeWriter(XmlMapping mapping, XmlWriter xmlWriter, object o, XmlSerializerNamespaces namespaces, string encodingStyle, string id)
    {
      XmlSerializationWriter writer = null;
      try
      {
        encodingStyle = ValidateEncodingStyle(encodingStyle, mapping.Key);
        writer = Contract.Writer;
        writer.Init(xmlWriter, namespaces, encodingStyle, id, this);
        if (methods[mapping.Key].writeMethod == null)
        {
          if (writerMethods == null)
          {
            writerMethods = Contract.WriteMethods;
          }
          string methodName = (string)writerMethods[mapping.Key];
          if (methodName == null)
          {
            throw new InvalidOperationException(Res.GetString(Res.XmlNotSerializable, mapping.Accessor.Name));
          }
          methods[mapping.Key].writeMethod = GetMethodFromType(writer.GetType(), methodName, pregeneratedAssmbly ? assembly : null);
        }
        methods[mapping.Key].writeMethod.Invoke(writer, new object[] { o });
      }
      catch (SecurityException e)
      {
        throw new InvalidOperationException(Res.GetString(Res.XmlNoPartialTrust), e);
      }
      finally
      {
        if (writer != null)
          writer.Dispose();
      }
    }

    internal Assembly GetReferencedAssembly(string name)
    {
      return assemblies != null && name != null ? (Assembly)assemblies[name] : null;
    }

    internal bool NeedAssembyResolve
    {
      get { return assemblies != null && assemblies.Count > 0; }
    }

    internal sealed class TempMethodDictionary : DictionaryBase
    {
      internal TempMethod this[string key]
      {
        get
        {
          return (TempMethod)Dictionary[key];
        }
      }
      internal void Add(string key, TempMethod value)
      {
        Dictionary.Add(key, value);
      }
    }
  }

  internal class CodeGeneratorConversionException : Exception
  {

    private Type sourceType;
    private Type targetType;
    private bool isAddress;
    private string reason;

    public CodeGeneratorConversionException(Type sourceType, Type targetType, bool isAddress, string reason)
      : base()
    {

      this.sourceType = sourceType;
      this.targetType = targetType;
      this.isAddress = isAddress;
      this.reason = reason;
    }
  }

  internal class Soap12
  {
    private Soap12() { }
    internal const string Encoding = "http://www.w3.org/2003/05/soap-encoding";
    internal const string RpcNamespace = "http://www.w3.org/2003/05/soap-rpc";
    internal const string RpcResult = "result";
  }

  /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlDeserializationEvents"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public struct XmlDeserializationEvents
  {
    XmlNodeEventHandler onUnknownNode;
    XmlAttributeEventHandler onUnknownAttribute;
    XmlElementEventHandler onUnknownElement;
    UnreferencedObjectEventHandler onUnreferencedObject;
    internal object sender;

    /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlDeserializationEvents.OnUnknownNode"]/*' />
    public XmlNodeEventHandler OnUnknownNode
    {
      get
      {
        return onUnknownNode;
      }
    }

    /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlDeserializationEvents.OnUnknownAttribute"]/*' />
    public XmlAttributeEventHandler OnUnknownAttribute
    {
      get
      {
        return onUnknownAttribute;
      }
    }

    /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlDeserializationEvents.OnUnknownElement"]/*' />
    public XmlElementEventHandler OnUnknownElement
    {
      get
      {
        return onUnknownElement;
      }
    }

    /// <include file='doc\XmlSerializer.uex' path='docs/doc[@for="XmlDeserializationEvents.OnUnreferencedObject"]/*' />
    public UnreferencedObjectEventHandler OnUnreferencedObject
    {
      get
      {
        return onUnreferencedObject;
      }
    }
  }

  /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventHandler"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public delegate void XmlNodeEventHandler(object sender, XmlNodeEventArgs e);

  /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlAttributeEventHandler"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public delegate void XmlAttributeEventHandler(object sender, XmlAttributeEventArgs e);

  /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlAttributeEventArgs"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public class XmlAttributeEventArgs : EventArgs
  {
    object o;
    XmlAttribute attr;
    string qnames;
    int lineNumber;
    int linePosition;


    internal XmlAttributeEventArgs(XmlAttribute attr, int lineNumber, int linePosition, object o, string qnames)
    {
      this.attr = attr;
      this.o = o;
      this.qnames = qnames;
      this.lineNumber = lineNumber;
      this.linePosition = linePosition;
    }
  }

  /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlElementEventHandler"]/*' />
  public delegate void XmlElementEventHandler(object sender, XmlElementEventArgs e);

  /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlElementEventArgs"]/*' />
  public class XmlElementEventArgs : EventArgs
  {
    object o;
    XmlElement elem;
    string qnames;
    int lineNumber;
    int linePosition;

    internal XmlElementEventArgs(XmlElement elem, int lineNumber, int linePosition, object o, string qnames)
    {
      this.elem = elem;
      this.o = o;
      this.qnames = qnames;
      this.lineNumber = lineNumber;
      this.linePosition = linePosition;
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlElementEventArgs.LineNumber"]/*' />
    public int LineNumber
    {
      get { return lineNumber; }
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlElementEventArgs.LinePosition"]/*' />
    public int LinePosition
    {
      get { return linePosition; }
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlAttributeEventArgs.ExpectedElements"]/*' />
    /// <devdoc>
    ///    <para>
    ///       List of qnames of elements expected in the current context.
    ///    </para>
    /// </devdoc>
    public string ExpectedElements
    {
      get { return qnames == null ? string.Empty : qnames; }
    }
  }

  /// <include file='doc\_Events.uex' path='docs/doc[@for="UnreferencedObjectEventHandler"]/*' />
  public delegate void UnreferencedObjectEventHandler(object sender, UnreferencedObjectEventArgs e);

  /// <include file='doc\_Events.uex' path='docs/doc[@for="UnreferencedObjectEventArgs"]/*' />
  public class UnreferencedObjectEventArgs : EventArgs
  {
    object o;
    string id;

    /// <include file='doc\_Events.uex' path='docs/doc[@for="UnreferencedObjectEventArgs.UnreferencedObjectEventArgs"]/*' />
    public UnreferencedObjectEventArgs(object o, string id)
    {
      this.o = o;
      this.id = id;
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="UnreferencedObjectEventArgs.UnreferencedObject"]/*' />
    public object UnreferencedObject
    {
      get { return o; }
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="UnreferencedObjectEventArgs.UnreferencedId"]/*' />
    public string UnreferencedId
    {
      get { return id; }
    }
  }

  /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs"]/*' />
  /// <devdoc>
  ///    <para>[To be supplied.]</para>
  /// </devdoc>
  public class XmlNodeEventArgs : EventArgs
  {
    object o;
    XmlNode xmlNode;
    int lineNumber;
    int linePosition;


    internal XmlNodeEventArgs(XmlNode xmlNode, int lineNumber, int linePosition, object o)
    {
      this.o = o;
      this.xmlNode = xmlNode;
      this.lineNumber = lineNumber;
      this.linePosition = linePosition;
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.ObjectBeingDeserialized"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public object ObjectBeingDeserialized
    {
      get { return o; }
    }


    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.NodeType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public XmlNodeType NodeType
    {
      get { return xmlNode.NodeType; }
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.Name"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string Name
    {
      get { return xmlNode.Name; }
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.LocalName"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string LocalName
    {
      get { return xmlNode.LocalName; }
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.NamespaceURI"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string NamespaceURI
    {
      get { return xmlNode.NamespaceURI; }
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.Text"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public string Text
    {
      get { return xmlNode.Value; }
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.LineNumber"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Gets the current line number.
    ///    </para>
    /// </devdoc>
    public int LineNumber
    {
      get { return lineNumber; }
    }

    /// <include file='doc\_Events.uex' path='docs/doc[@for="XmlNodeEventArgs.LinePosition"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Gets the current line position.
    ///    </para>
    /// </devdoc>
    public int LinePosition
    {
      get { return linePosition; }
    }
  }
}
